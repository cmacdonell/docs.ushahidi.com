{
  "name": "flatnest",
  "version": "1.0.0",
  "description": "Flatten/Nest Javascript objects.",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {},
  "devDependencies": {
    "tape": "~4.0.0"
  },
  "scripts": {
    "test": "node test/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/brycebaril/node-flatnest.git"
  },
  "keywords": [
    "flatten",
    "nest",
    "keyspec"
  ],
  "author": {
    "name": "Bryce B. Baril"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/brycebaril/node-flatnest/issues"
  },
  "readme": "flatnest\n=====\n\n[![NPM](https://nodei.co/npm/flatnest.png)](https://nodei.co/npm/flatnest/)\n\nFlatten/Nest Javascript objects.\n\n```javascript\n\nvar fn = require(\"flatnest\")\n\nvar obj = {\n  cat: \"meow\",\n  dog: [{name: \"spot\"}, {name: \"rover\"}],\n  bird: {type: \"parrot\", age: 22.3, stats: {weight: 10, height: 15}}\n}\n\nvar flat = fn.flatten(obj)\n\n/*\n{ cat: 'meow',\n  'dog[0].name': 'spot',\n  'dog[1].name': 'rover',\n  'bird.type': 'parrot',\n  'bird.age': 22.3,\n  'bird.stats.weight': 10,\n  'bird.stats.height': 15 }\n */\n\n\nvar nested = fn.nest(flat)\n\n/*\n{ cat: 'meow',\n  dog: [ { name: 'spot' }, { name: 'rover' } ],\n  bird:\n   { type: 'parrot',\n     age: 22.3,\n     stats: { weight: 10, height: 15 } } }\n */\n\n// An internal `seek` function is also exposed:\n\nfn.seek(obj, \"bird.stats.height\") // 15\n\n\n```\n\nAPI\n===\n\n`flatten(object)`\n---\n\nFlatten an object to a javascript object with only key: value pairs where values are not complex data types. (e.g. they can be numbers, strings, booleans, but not Objects or Arrays)\n\nKeys are named with paths to where the keys where when nested.\n\n`nest(flatObject)`\n---\n\nRe-form a flattend object into the nested version. It parses the key paths set during flattening and should end up with the original version. This is not always true depending on what data was present and the original key names chosen.\n\n`seek(object, path)`\n---\n\nUse the flattened key syntax (e.g. `aa.bb[0].cc`) to look into a nested object.\n\nNOTES\n===\n\nIt attempts to do the right thing in a few cases, such as circular references, and will probably not do what you want if you're using `.` or `[]` already in your key names (why would you do that!?!)\n\nCircular example:\n```javascript\nvar fn = require(\"flatnest\")\n\nvar obj = {\n  aa: \"cat\",\n}\nobj.bb = obj\n\nconsole.log(obj)\n\n// { aa: 'cat', bb: [Circular] }\n\n// Will insert a string value of [Circular (ref)] pointing to the location this ref was first seen while flattening.\nvar flat = fn.flatten(obj)\n\nconsole.log(flat)\n\n// { aa: 'cat', bb: '[Circular (this)]' }\n\nvar nested = fn.nest(obj)\n\n// { aa: 'cat', bb: { aa: 'cat', bb: [Circular] } }\n\nconsole.log(nested)\n```\n\nLICENSE\n=======\n\nMIT\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/brycebaril/node-flatnest",
  "_id": "flatnest@1.0.0",
  "dist": {
    "shasum": "1e399bcbcf32463af6743757b10b0c5d082b2625"
  },
  "_from": "flatnest@^1.0.0",
  "_resolved": "https://registry.npmjs.org/flatnest/-/flatnest-1.0.0.tgz"
}
